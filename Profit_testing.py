
from matplotlib.colors import ListedColormap



#=============================================================================== Plot generating code
y_1 = x_test_
x_1 = model_fitted_calibrated

cmap = ListedColormap(['red', 'blue'])

plt.scatter(x_1,y_1,marker = 'o', c = y_test, s= 12 , cmap = cmap, alpha=.244)
plt.grid(True, which='both', axis='both', linestyle='--', color='gray', alpha=0.3)
plt.minorticks_on()  # Enable minor gridlines

legend_labels = [' ']
legend_colors = ['blue']  # The colors corresponding to the binary categories

# Add gridlines for both major and minor ticks
plt.grid(True, which='minor', axis='both', linestyle=':', color='blue', alpha=0.3)  # Minor gridlines
plt.axhline(y=0.5, color='black', linestyle='--', label='y = 0.5',alpha = .65)
plt.axvline(x=0.5, color='black', linestyle='--', label='x = 0.5',alpha = .65)
plt.axvline(x=0.2, color='pink', linestyle='-', label='x = 0.18',alpha = .95)
plt.axvline(x=0.8, color='pink', linestyle='-', label='x = 0.82',alpha = .95)

slope = 1
intercept = 0
# Create an array of x-values (from -10 to 10)
line_x_values = np.linspace(0.15, .85, 200)

# Compute corresponding y-values using y = mx (since the intercept is 0)
line_y_values = slope * line_x_values + intercept

# Create a plot
plt.plot(line_x_values, line_y_values, label=f'Line: y = {slope}x', color='black')
plt.xlabel('My_Model\'s_projected_win_probability')
plt.ylabel('Pinnacle/Circa_implied_win_probability(w/vigorish)')
plt.title('Vegas Sports books vs betting model')

plt.text(0.5, 1, 'Public favorites', fontsize=9, color='black', ha='center')
plt.text(0.5, .05, 'Public underdogs', fontsize=9, color='black', ha='center')

plt.text(0.09, .95, 'Blue dots = Game Won', fontsize=7, color='blue', ha='center')
plt.text(0.09, .9, 'Red dots = Game Lost', fontsize=7, color='red', ha='center')


plt.xlim(0.18,.85)
plt.ylim(0,1)

plt.axis('equal')
# Show the plot
#===============================================================================
plt.show()

#===============================================================================  Profit-testing begins here
df = pd.DataFrame({
    'model_predicted_prob': x_1,
    'pinnacle_implied_probability': y_1,
    'binary_outcome_win_loss': y_test

})

# Placing bets where the model provides a stronger implied probability than the sportsbooks is the foundation of 
# positive EV betting....

df = df[df['model_predicted_prob'] > (df['pinnacle_implied_probability'])]

# Vegas sportbetting apps offer different pre-game odds so value can be found
# by exploiting the market generated by different betting apps (Circa, Westgate, MGM, William Hill, etc). Some apps offter
# an implied probability differential between 0 and .03 with some differences being up to .05
line_shopped_value = .02 # <- should be between 0 and .02 but can be up .05
df['percentage_of_wager_returned'] = my_odds_to_payout_function(df['pinnacle_implied_probability'])

wager = 1 # <- unit amount bet

df['net_change_from_wager'] = np.where(df['binary_outcome_win_loss'] == 1, wager*df['percentage_of_wager_returned'], (-1)*wager)

print("Net gain or loss is :: ", df['net_change_from_wager'].sum())

df['cumulative_sum'] = df['net_change_from_wager'].cumsum()

row_numbers = range(1, len(df) + 1)
plt.figure(figsize=(12, 6))

plt.plot(row_numbers, df['cumulative_sum'], color='b',alpha = .45, linestyle='-', label="Profit/Loss trend line")

plt.title('[Backtested] Cumulative Sum of Betting Wins and Losses against scraped pinnacle NBA ML odds')
plt.xlabel('Number of +EV Bets Placed')
plt.ylabel('Net Gain/Loss of Units')
plt.legend()
plt.grid(True)
plt.axhline(y=0, color='red', linewidth=4)

plt.show()
raise SystemExit()
